{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // Generated by CoffeeScript 2.5.1\n\n\nvar Block, SpecialString, cloneAndMergeDeep, terminalWidth;\nSpecialString = require('./SpecialString');\nterminalWidth = require('../tools').getCols();\n\nvar _require = require('../tools');\n\ncloneAndMergeDeep = _require.cloneAndMergeDeep;\n\nmodule.exports = Block = function () {\n  var self;\n\n  var Block = /*#__PURE__*/function () {\n    function Block(_layout, _parent) {\n      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n      _classCallCheck(this, Block);\n\n      this._layout = _layout;\n      this._parent = _parent;\n      this._name = _name;\n      this._config = cloneAndMergeDeep(self.defaultConfig, config);\n      this._closed = false;\n      this._wasOpenOnce = false;\n      this._active = false;\n      this._buffer = '';\n      this._didSeparateBlock = false;\n      this._linePrependor = new this._config.linePrependor.fn(this._config.linePrependor.options);\n      this._lineAppendor = new this._config.lineAppendor.fn(this._config.lineAppendor.options);\n      this._blockPrependor = new this._config.blockPrependor.fn(this._config.blockPrependor.options);\n      this._blockAppendor = new this._config.blockAppendor.fn(this._config.blockAppendor.options);\n    }\n\n    _createClass(Block, [{\n      key: \"_activate\",\n      value: function _activate() {\n        var deactivateParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n        if (this._active) {\n          throw Error(\"This block is already active. This is probably a bug in RenderKid itself\");\n        }\n\n        if (this._closed) {\n          throw Error(\"This block is closed and cannot be activated. This is probably a bug in RenderKid itself\");\n        }\n\n        this._active = true;\n        this._layout._activeBlock = this;\n\n        if (deactivateParent) {\n          if (this._parent != null) {\n            this._parent._deactivate(false);\n          }\n        }\n\n        return this;\n      }\n    }, {\n      key: \"_deactivate\",\n      value: function _deactivate() {\n        var activateParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n        this._ensureActive();\n\n        this._flushBuffer();\n\n        if (activateParent) {\n          if (this._parent != null) {\n            this._parent._activate(false);\n          }\n        }\n\n        this._active = false;\n        return this;\n      }\n    }, {\n      key: \"_ensureActive\",\n      value: function _ensureActive() {\n        if (!this._wasOpenOnce) {\n          throw Error(\"This block has never been open before. This is probably a bug in RenderKid itself.\");\n        }\n\n        if (!this._active) {\n          throw Error(\"This block is not active. This is probably a bug in RenderKid itself.\");\n        }\n\n        if (this._closed) {\n          throw Error(\"This block is already closed. This is probably a bug in RenderKid itself.\");\n        }\n      }\n    }, {\n      key: \"_open\",\n      value: function _open() {\n        if (this._wasOpenOnce) {\n          throw Error(\"Block._open() has been called twice. This is probably a RenderKid bug.\");\n        }\n\n        this._wasOpenOnce = true;\n\n        if (this._parent != null) {\n          this._parent.write(this._whatToPrependToBlock());\n        }\n\n        this._activate();\n\n        return this;\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        this._deactivate();\n\n        this._closed = true;\n\n        if (this._parent != null) {\n          this._parent.write(this._whatToAppendToBlock());\n        }\n\n        return this;\n      }\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return this._wasOpenOnce && !this._closed;\n      }\n    }, {\n      key: \"write\",\n      value: function write(str) {\n        this._ensureActive();\n\n        if (str === '') {\n          return;\n        }\n\n        str = String(str);\n        this._buffer += str;\n        return this;\n      }\n    }, {\n      key: \"openBlock\",\n      value: function openBlock(config, name) {\n        var block;\n\n        this._ensureActive();\n\n        block = new Block(this._layout, this, config, name);\n\n        block._open();\n\n        return block;\n      }\n    }, {\n      key: \"_flushBuffer\",\n      value: function _flushBuffer() {\n        var str;\n\n        if (this._buffer === '') {\n          return;\n        }\n\n        str = this._buffer;\n        this._buffer = '';\n\n        this._writeInline(str);\n      }\n    }, {\n      key: \"_toPrependToLine\",\n      value: function _toPrependToLine() {\n        var fromParent;\n        fromParent = '';\n\n        if (this._parent != null) {\n          fromParent = this._parent._toPrependToLine();\n        }\n\n        return this._linePrependor.render(fromParent);\n      }\n    }, {\n      key: \"_toAppendToLine\",\n      value: function _toAppendToLine() {\n        var fromParent;\n        fromParent = '';\n\n        if (this._parent != null) {\n          fromParent = this._parent._toAppendToLine();\n        }\n\n        return this._lineAppendor.render(fromParent);\n      }\n    }, {\n      key: \"_whatToPrependToBlock\",\n      value: function _whatToPrependToBlock() {\n        return this._blockPrependor.render();\n      }\n    }, {\n      key: \"_whatToAppendToBlock\",\n      value: function _whatToAppendToBlock() {\n        return this._blockAppendor.render();\n      }\n    }, {\n      key: \"_writeInline\",\n      value: function _writeInline(str) {\n        var i, j, k, l, lineBreaksToAppend, m, ref, ref1, ref2, remaining; // special characters (such as <bg-white>) don't require\n        // any wrapping...\n\n        if (new SpecialString(str).isOnlySpecialChars()) {\n          // ... and directly get appended to the layout.\n          this._layout._append(str);\n\n          return;\n        } // we'll be removing from the original string till it's empty\n\n\n        remaining = str; // we might need to add a few line breaks at the end of the text.\n\n        lineBreaksToAppend = 0; // if text starts with line breaks...\n\n        if (m = remaining.match(/^\\n+/)) {\n          // ... we want to write the exact same number of line breaks\n          // to the layout.\n          for (i = j = 1, ref = m[0].length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n            this._writeLine('');\n          }\n\n          remaining = remaining.substr(m[0].length, remaining.length);\n        } // and if the text ends with line breaks...\n\n\n        if (m = remaining.match(/\\n+$/)) {\n          // we want to write the exact same number of line breaks\n          // to the end of the layout.\n          lineBreaksToAppend = m[0].length;\n          remaining = remaining.substr(0, remaining.length - m[0].length);\n        } // now let's parse the body of the text:\n\n\n        while (remaining.length > 0) {\n          // anything other than a break line...\n          if (m = remaining.match(/^[^\\n]+/)) {\n            // ... should be wrapped as a block of text.\n            this._writeLine(m[0]);\n\n            remaining = remaining.substr(m[0].length, remaining.length); // for any number of line breaks we find inside the text...\n          } else if (m = remaining.match(/^\\n+/)) {\n            // ... we write one less break line to the layout.\n            for (i = k = 1, ref1 = m[0].length; 1 <= ref1 ? k < ref1 : k > ref1; i = 1 <= ref1 ? ++k : --k) {\n              this._writeLine('');\n            }\n\n            remaining = remaining.substr(m[0].length, remaining.length);\n          }\n        } // if we had line breaks to append to the layout...\n\n\n        if (lineBreaksToAppend > 0) {\n          // ... we append the exact same number of line breaks to the layout.\n          for (i = l = 1, ref2 = lineBreaksToAppend; 1 <= ref2 ? l <= ref2 : l >= ref2; i = 1 <= ref2 ? ++l : --l) {\n            this._writeLine('');\n          }\n        }\n      } // wraps a line into multiple lines if necessary, adds horizontal margins,\n      // etc, and appends it to the layout.\n\n    }, {\n      key: \"_writeLine\",\n      value: function _writeLine(str) {\n        var line, lineContent, lineContentLength, remaining, roomLeft, toAppend, toAppendLength, toPrepend, toPrependLength; // we'll be cutting from our string as we go\n\n        remaining = new SpecialString(str);\n\n        while (true) {\n          // left margin...\n          // this will continue until nothing is left of our block.\n          toPrepend = this._toPrependToLine(); // ... and its length\n\n          toPrependLength = new SpecialString(toPrepend).length; // right margin...\n\n          toAppend = this._toAppendToLine(); // ... and its length\n\n          toAppendLength = new SpecialString(toAppend).length; // how much room is left for content\n\n          roomLeft = this._layout._config.terminalWidth - (toPrependLength + toAppendLength); // how much room each line of content will have\n\n          lineContentLength = Math.min(this._config.width, roomLeft); // cut line content, only for the amount needed\n\n          lineContent = remaining.cut(0, lineContentLength, true); // line will consist of both margins and the content\n\n          line = toPrepend + lineContent.str + toAppend; // send it off to layout\n\n          this._layout._appendLine(line);\n\n          if (remaining.isEmpty()) {\n            break;\n          }\n        }\n      }\n    }]);\n\n    return Block;\n  }();\n\n  ;\n  self = Block;\n  Block.defaultConfig = {\n    blockPrependor: {\n      fn: require('./block/blockPrependor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    blockAppendor: {\n      fn: require('./block/blockAppendor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    linePrependor: {\n      fn: require('./block/linePrependor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    lineAppendor: {\n      fn: require('./block/lineAppendor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    lineWrapper: {\n      fn: require('./block/lineWrapper/Default'),\n      options: {\n        lineWidth: null\n      }\n    },\n    width: terminalWidth,\n    prefixRaw: '',\n    suffixRaw: ''\n  };\n  return Block;\n}.call(void 0);","map":{"version":3,"sources":["/home/am-pc-05-other/React/latest Live exam Portal/Live-Exam-Portal/node_modules/renderkid/lib/layout/Block.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Block","SpecialString","cloneAndMergeDeep","terminalWidth","require","getCols","_require","module","exports","self","_layout","_parent","config","arguments","undefined","_name","_config","defaultConfig","_closed","_wasOpenOnce","_active","_buffer","_didSeparateBlock","_linePrependor","linePrependor","fn","options","_lineAppendor","lineAppendor","_blockPrependor","blockPrependor","_blockAppendor","blockAppendor","value","_activate","deactivateParent","Error","_activeBlock","_deactivate","activateParent","_ensureActive","_flushBuffer","_open","write","_whatToPrependToBlock","close","_whatToAppendToBlock","isOpen","str","String","openBlock","name","block","_writeInline","_toPrependToLine","fromParent","render","_toAppendToLine","j","k","l","lineBreaksToAppend","m","ref","ref1","ref2","remaining","isOnlySpecialChars","_append","match","_writeLine","substr","line","lineContent","lineContentLength","roomLeft","toAppend","toAppendLength","toPrepend","toPrependLength","Math","min","width","cut","_appendLine","isEmpty","amount","lineWrapper","lineWidth","prefixRaw","suffixRaw","call"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Generated by CoffeeScript 2.5.1\nvar Block, SpecialString, cloneAndMergeDeep, terminalWidth;\nSpecialString = require('./SpecialString');\nterminalWidth = require('../tools').getCols();\n\nvar _require = require('../tools');\n\ncloneAndMergeDeep = _require.cloneAndMergeDeep;\n\nmodule.exports = Block = function () {\n  var self;\n\n  var Block = /*#__PURE__*/function () {\n    function Block(_layout, _parent) {\n      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n      _classCallCheck(this, Block);\n\n      this._layout = _layout;\n      this._parent = _parent;\n      this._name = _name;\n      this._config = cloneAndMergeDeep(self.defaultConfig, config);\n      this._closed = false;\n      this._wasOpenOnce = false;\n      this._active = false;\n      this._buffer = '';\n      this._didSeparateBlock = false;\n      this._linePrependor = new this._config.linePrependor.fn(this._config.linePrependor.options);\n      this._lineAppendor = new this._config.lineAppendor.fn(this._config.lineAppendor.options);\n      this._blockPrependor = new this._config.blockPrependor.fn(this._config.blockPrependor.options);\n      this._blockAppendor = new this._config.blockAppendor.fn(this._config.blockAppendor.options);\n    }\n\n    _createClass(Block, [{\n      key: \"_activate\",\n      value: function _activate() {\n        var deactivateParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n        if (this._active) {\n          throw Error(\"This block is already active. This is probably a bug in RenderKid itself\");\n        }\n\n        if (this._closed) {\n          throw Error(\"This block is closed and cannot be activated. This is probably a bug in RenderKid itself\");\n        }\n\n        this._active = true;\n        this._layout._activeBlock = this;\n\n        if (deactivateParent) {\n          if (this._parent != null) {\n            this._parent._deactivate(false);\n          }\n        }\n\n        return this;\n      }\n    }, {\n      key: \"_deactivate\",\n      value: function _deactivate() {\n        var activateParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n        this._ensureActive();\n\n        this._flushBuffer();\n\n        if (activateParent) {\n          if (this._parent != null) {\n            this._parent._activate(false);\n          }\n        }\n\n        this._active = false;\n        return this;\n      }\n    }, {\n      key: \"_ensureActive\",\n      value: function _ensureActive() {\n        if (!this._wasOpenOnce) {\n          throw Error(\"This block has never been open before. This is probably a bug in RenderKid itself.\");\n        }\n\n        if (!this._active) {\n          throw Error(\"This block is not active. This is probably a bug in RenderKid itself.\");\n        }\n\n        if (this._closed) {\n          throw Error(\"This block is already closed. This is probably a bug in RenderKid itself.\");\n        }\n      }\n    }, {\n      key: \"_open\",\n      value: function _open() {\n        if (this._wasOpenOnce) {\n          throw Error(\"Block._open() has been called twice. This is probably a RenderKid bug.\");\n        }\n\n        this._wasOpenOnce = true;\n\n        if (this._parent != null) {\n          this._parent.write(this._whatToPrependToBlock());\n        }\n\n        this._activate();\n\n        return this;\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        this._deactivate();\n\n        this._closed = true;\n\n        if (this._parent != null) {\n          this._parent.write(this._whatToAppendToBlock());\n        }\n\n        return this;\n      }\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return this._wasOpenOnce && !this._closed;\n      }\n    }, {\n      key: \"write\",\n      value: function write(str) {\n        this._ensureActive();\n\n        if (str === '') {\n          return;\n        }\n\n        str = String(str);\n        this._buffer += str;\n        return this;\n      }\n    }, {\n      key: \"openBlock\",\n      value: function openBlock(config, name) {\n        var block;\n\n        this._ensureActive();\n\n        block = new Block(this._layout, this, config, name);\n\n        block._open();\n\n        return block;\n      }\n    }, {\n      key: \"_flushBuffer\",\n      value: function _flushBuffer() {\n        var str;\n\n        if (this._buffer === '') {\n          return;\n        }\n\n        str = this._buffer;\n        this._buffer = '';\n\n        this._writeInline(str);\n      }\n    }, {\n      key: \"_toPrependToLine\",\n      value: function _toPrependToLine() {\n        var fromParent;\n        fromParent = '';\n\n        if (this._parent != null) {\n          fromParent = this._parent._toPrependToLine();\n        }\n\n        return this._linePrependor.render(fromParent);\n      }\n    }, {\n      key: \"_toAppendToLine\",\n      value: function _toAppendToLine() {\n        var fromParent;\n        fromParent = '';\n\n        if (this._parent != null) {\n          fromParent = this._parent._toAppendToLine();\n        }\n\n        return this._lineAppendor.render(fromParent);\n      }\n    }, {\n      key: \"_whatToPrependToBlock\",\n      value: function _whatToPrependToBlock() {\n        return this._blockPrependor.render();\n      }\n    }, {\n      key: \"_whatToAppendToBlock\",\n      value: function _whatToAppendToBlock() {\n        return this._blockAppendor.render();\n      }\n    }, {\n      key: \"_writeInline\",\n      value: function _writeInline(str) {\n        var i, j, k, l, lineBreaksToAppend, m, ref, ref1, ref2, remaining; // special characters (such as <bg-white>) don't require\n        // any wrapping...\n\n        if (new SpecialString(str).isOnlySpecialChars()) {\n          // ... and directly get appended to the layout.\n          this._layout._append(str);\n\n          return;\n        } // we'll be removing from the original string till it's empty\n\n\n        remaining = str; // we might need to add a few line breaks at the end of the text.\n\n        lineBreaksToAppend = 0; // if text starts with line breaks...\n\n        if (m = remaining.match(/^\\n+/)) {\n          // ... we want to write the exact same number of line breaks\n          // to the layout.\n          for (i = j = 1, ref = m[0].length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n            this._writeLine('');\n          }\n\n          remaining = remaining.substr(m[0].length, remaining.length);\n        } // and if the text ends with line breaks...\n\n\n        if (m = remaining.match(/\\n+$/)) {\n          // we want to write the exact same number of line breaks\n          // to the end of the layout.\n          lineBreaksToAppend = m[0].length;\n          remaining = remaining.substr(0, remaining.length - m[0].length);\n        } // now let's parse the body of the text:\n\n\n        while (remaining.length > 0) {\n          // anything other than a break line...\n          if (m = remaining.match(/^[^\\n]+/)) {\n            // ... should be wrapped as a block of text.\n            this._writeLine(m[0]);\n\n            remaining = remaining.substr(m[0].length, remaining.length); // for any number of line breaks we find inside the text...\n          } else if (m = remaining.match(/^\\n+/)) {\n            // ... we write one less break line to the layout.\n            for (i = k = 1, ref1 = m[0].length; 1 <= ref1 ? k < ref1 : k > ref1; i = 1 <= ref1 ? ++k : --k) {\n              this._writeLine('');\n            }\n\n            remaining = remaining.substr(m[0].length, remaining.length);\n          }\n        } // if we had line breaks to append to the layout...\n\n\n        if (lineBreaksToAppend > 0) {\n          // ... we append the exact same number of line breaks to the layout.\n          for (i = l = 1, ref2 = lineBreaksToAppend; 1 <= ref2 ? l <= ref2 : l >= ref2; i = 1 <= ref2 ? ++l : --l) {\n            this._writeLine('');\n          }\n        }\n      } // wraps a line into multiple lines if necessary, adds horizontal margins,\n      // etc, and appends it to the layout.\n\n    }, {\n      key: \"_writeLine\",\n      value: function _writeLine(str) {\n        var line, lineContent, lineContentLength, remaining, roomLeft, toAppend, toAppendLength, toPrepend, toPrependLength; // we'll be cutting from our string as we go\n\n        remaining = new SpecialString(str);\n\n        while (true) {\n          // left margin...\n          // this will continue until nothing is left of our block.\n          toPrepend = this._toPrependToLine(); // ... and its length\n\n          toPrependLength = new SpecialString(toPrepend).length; // right margin...\n\n          toAppend = this._toAppendToLine(); // ... and its length\n\n          toAppendLength = new SpecialString(toAppend).length; // how much room is left for content\n\n          roomLeft = this._layout._config.terminalWidth - (toPrependLength + toAppendLength); // how much room each line of content will have\n\n          lineContentLength = Math.min(this._config.width, roomLeft); // cut line content, only for the amount needed\n\n          lineContent = remaining.cut(0, lineContentLength, true); // line will consist of both margins and the content\n\n          line = toPrepend + lineContent.str + toAppend; // send it off to layout\n\n          this._layout._appendLine(line);\n\n          if (remaining.isEmpty()) {\n            break;\n          }\n        }\n      }\n    }]);\n\n    return Block;\n  }();\n\n  ;\n  self = Block;\n  Block.defaultConfig = {\n    blockPrependor: {\n      fn: require('./block/blockPrependor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    blockAppendor: {\n      fn: require('./block/blockAppendor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    linePrependor: {\n      fn: require('./block/linePrependor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    lineAppendor: {\n      fn: require('./block/lineAppendor/Default'),\n      options: {\n        amount: 0\n      }\n    },\n    lineWrapper: {\n      fn: require('./block/lineWrapper/Default'),\n      options: {\n        lineWidth: null\n      }\n    },\n    width: terminalWidth,\n    prefixRaw: '',\n    suffixRaw: ''\n  };\n  return Block;\n}.call(void 0);"]},"metadata":{},"sourceType":"script"}